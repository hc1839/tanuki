#include "tanuki/math/linear/number_array.h"

#include <algorithm>
#include <cassert>
#include <fstream>
#include <memory>
#include <numeric>
#include <string>

#include <avro/Compiler.hh>

#include "tanuki/avro_specific/size_t.h"

namespace tanuki {
namespace math {
namespace linear {

using std::ifstream;
using std::string;
using std::unique_ptr;

const avro::ValidSchema &NumberArray::AvroSchema() {
  static unique_ptr<avro::ValidSchema> schema;

  if (schema == nullptr) {
    schema.reset(new avro::ValidSchema());

    string avsc_path;

    avsc_path += "@CMAKE_INSTALL_PREFIX@";
    avsc_path += "/@CMAKE_INSTALL_DATAROOTDIR@";
    avsc_path += "/tanuki/math/linear/number_array.avsc";

    ifstream ifs(avsc_path);
    avro::compileJsonSchema(ifs, *schema);
  }

  return *schema;
}

size_t NumberArray::num_elems() const {
  return std::accumulate(
      extents.begin(), extents.end(), 1,
      [](const size_t &acc, const size_t &item) -> size_t {
        return acc * item;
      });
}

} // namespace linear
} // namespace math
} // namespace tanuki

namespace avro {

using std::vector;

void codec_traits<NumberArray>::encode(Encoder &e, const NumberArray &o) {
#ifndef TANUKI_NO_DEBUG
  {
    const size_t num_elems = o.num_elems();

    assert(o.real.size() == num_elems);

    if (o.is_complex) {
      assert(o.imag.size() == num_elems);
    }
  }
#endif

  avro::encode(e, o.is_complex);
  avro::encode(e, o.extents);
  avro::encode(e, o.real);
  avro::encode(e, o.imag);
}

void codec_traits<NumberArray>::decode(Decoder &d, NumberArray &o) {
  avro::decode(d, o.is_complex);
  avro::decode(d, o.extents);
  avro::decode(d, o.real);
  avro::decode(d, o.imag);

#ifndef TANUKI_NO_DEBUG
  {
    const size_t num_elems = o.num_elems();

    assert(o.real.size() == num_elems);

    if (o.is_complex) {
      assert(o.imag.size() == num_elems);
    }
  }
#endif
}

} // namespace avro
